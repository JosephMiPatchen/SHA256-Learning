# Evol Numbers: A Comprehensive Guide

## Overview
**Evol Numbers** are a sequence generation mechanism defined by a specific set of rules. They start with an initial seed (a list of numbers) and evolve by applying a deterministic function where each element is computed as the sum of the two previous elements. Additionally, the second-to-last element is updated to the sum of the current element being calculated and a constant parameter, c. This mechanism ensures the growth of the sequence is influenced by both recursive summation and the constant addition of c. This system has applications in algorithm design, mathematical exploration, and potentially cryptographic or pseudorandom sequence generation.

This README provides a detailed explanation of how Evol Numbers work, including an example with a seed of `[3, 1]`, c = 2, and n = 8.

## Key Variables
The Evol Numbers system revolves around three main variables:

1. **Seed**:
   - A list of numbers that seeds the sequence generation process.
   - Example: `[3, 1]` in this case.

2. **Constant c**:
   - A fixed value added during each iteration to influence the sequence's growth.
   - Example: c = 2.

3. **Buffer Length (n)**:
   - The total number of elements in the buffer to be calculated.
   - Example: n = 8.

These variables determine the sequence's initial configuration and how it evolves over time.

## General Formula
For any given iteration n >= 2:

1. Compute the current element via the sum of the two previous elements:
   ```
   buff[i] = buff[i-1] + buff[i-2]
   ```

2. Update the previous element to the sum of the current element and the constant c:
   ```
   buff[i-1] = buff[i] + c
   ```

---

## Evol Numbers Example
Here’s how the buffer evolves through iterations with:
- **Seed**: `[3, 1]`
- **Constant c**: 2
- **Buffer Length (n)**: 8

The sequence fills the buffer entirely in 7 iterations, with the 7th iteration producing the final buffer:

| Iteration | Buffer                                 |
|-----------|----------------------------------------|
| Initial   | [3, 1, 0, 0, 0, 0, 0, 0, 0]           |
| 1         | [3, 6, 4, 0, 0, 0, 0, 0, 0]           |
| 2         | [3, 6, 12, 10, 0, 0, 0, 0, 0]         |
| 3         | [3, 6, 12, 24, 22, 0, 0, 0, 0]        |
| 4         | [3, 6, 12, 24, 48, 46, 0, 0, 0]       |
| 5         | [3, 6, 12, 24, 48, 96, 94, 0, 0]      |
| 6         | [3, 6, 12, 24, 48, 96, 192, 190, 0]   |
| 7 (Final) | [3, 6, 12, 24, 48, 96, 192, 384, 382] |

---

## Properties of Evol Numbers
### 1. **Growth Pattern**:
   - The sequence grows in a unique pattern, influenced both by recursive summation and the addition of c.

### 2. **Dependence on Seed**:
   - Different seeds lead to entirely different sequences, even with the same constant c.

### 3. **Adjustable Behavior**:
   - Changing c affects the growth rate and structure of the sequence.

### 4. **Fixed Buffer Length (n)**:
   - The total buffer size n determines how many iterations are needed to fully populate the sequence.

### 5. **Invariant Properties**:
   The following properties hold regardless of the choice of c or the seed:
   - **Doubling Relationship**:
     Starting from the third element, each element up to the second-to-last is exactly double the previous element:
     
     buff[i] = 2 * buff[i-1] for 2 <= i < n-1.
   
   - **Last Element Offset**:
     The last element is always the second-to-last element minus c:
     
     buff[n-1] = buff[n-2] - c.
   
   - **Second Element Dependency**:
     The second element is directly influenced by the seed and c:
     
     buff[1] = buff[0] + buff[1] + c.
   
   - **Seed Independence of Doubling**:
     The doubling relationship between elements beyond the second does not depend on the specific seed values or c.

---

## Code
Here’s a Python implementation to generate Evol Numbers:

```python
# Evol Numbers Generator
def evol_nums(n=8, seed=[3, 1], c=2):
    buff = seed + ([0] * (n - 2))
    for i in range(2, len(buff)):
        buff[i] = buff[i-1] + buff[i-2]
        buff[i-1] = buff[i] + c
    print(f"buff: {buff}")

# Example Usage
seed = [3, 1]
c = 2
evol_nums(n=8, seed=seed, c=c)
```

## New Formula for Final Buffer
By analyzing the structure of the algorithm, a formula was derived to calculate the final buffer directly, without iterating through the algorithm. This formula is based on observing patterns generated by the recursive summation and constant updates.

### The Formula
1. **Initial Condition:**
   buff[0] = x
   where x is the first element of the seed.

2. **Intermediate Elements** (for 1 <= i <= n-2):
   buff[i] = 2^(i-1) * (x + y + c)
   where y is the second element of the seed.

3. **Final Element:**
   buff[n-1] = (2^(n-3) * (x + y + c)) - c

### Derivation of the Formula
The formula was derived by running the algorithm with variables x, y, and c (representing the seed and constant) instead of specific numbers, and observing the resulting patterns. By explicitly tracking how each buffer element is computed and influenced by the overwrite step, the general pattern emerged:
- Each element is scaled exponentially by a factor of 2.
- The final element deviates due to the subtraction of c in the last overwrite.

This approach ensures the formula generalizes for any seed [x, y], constant c, and buffer size n.

## Formula Code
Here’s a Python implementation to generate Evol Numbers:

```python
def evol_num_formula(n, seed, c):
    x, y = seed
    formula_buffer = [0] * n
    formula_buffer[0] = x
    for i in range(1, n - 1):
        formula_buffer[i] = 2 ** (i - 1) * (x + y + c)
    formula_buffer[n - 1] = (2 ** (n - 3) * (x + y + c)) - c
    return formula_buffer
```